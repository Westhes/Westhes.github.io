(()=>{var g=class{constructor(t,e){this.fps=0,this.canvas=document.getElementById("gameWindow"),this.canvas.width=document.body.clientWidth,this.canvas.height=320,this.width=this.canvas.width,this.height=this.canvas.height,this.context=this.canvas.getContext("2d"),this.lastUpdate=0,this.lastFixedUpdate=0,this.lastFrame=0,this.targetFixedUpdate=1/e,this.targetFixedUpdateMS=1e3/e,this.targetFrameRate=1/t,this.targetFrameRateMS=1e3/t,this.stopped=!l,this.gameObjects=[],this.updateMethod=g.GetUpdateMethod(),new ResizeObserver(this.onWindowResize.bind(this)).observe(document.body),window.addEventListener("keydown",this.input.bind(this),!1),this.startLoop()}startLoop(){let t=performance.now();this.lastUpdate=t,this.lastFixedUpdate=t-this.targetFixedUpdateMS,this.lastFrame=t-this.targetFrameRateMS,this.updateMethod(this.gameLoop.bind(this))}gameLoop(){if(this.updateMethod(this.gameLoop.bind(this)),l)this.stopped&&(this.stopped=!1,this.startLoop());else return;let t=performance.now(),e=(t-this.lastUpdate)/1e3,i=(t-this.lastFixedUpdate)/1e3,s=(t-this.lastFrame)/1e3;this.lastUpdate=t;try{i>=this.targetFixedUpdate&&(this.lastFixedUpdate=t-(t-this.lastFixedUpdate-this.targetFixedUpdateMS),this.fixedUpdate(this.targetFixedUpdate,t)),this.update(e,t),s>=this.targetFrameRate&&(this.lastFrame=t-(t-this.lastFrame-this.targetFrameRateMS),this.render())}catch(o){l=!1}this.stopped=!l}onWindowResize(){this.canvas.width=document.body.clientWidth,this.width=this.canvas.width,this.context.clearRect(0,0,this.canvas.width,this.canvas.height),this.gameObjects.forEach(t=>{t.onCanvasResize(this.width,this.height,this.context)})}update(t,e){this.gameObjects.forEach(i=>{i.update(t,e)})}fixedUpdate(t,e){this.gameObjects.forEach(i=>{i.fixedUpdate(t,e)})}render(){this.context.clearRect(0,0,this.canvas.width,this.canvas.height),this.gameObjects.forEach(t=>{t.render(this.context)})}input(t){let e=t.keyCode;switch(e){case 27:case 80:l=!l,console.log("Is Playing = ",l),l===!0&&this.startLoop();break;default:console.log(e);break}}addGameobject(t){this.gameObjects.push(t),t.onCanvasResize(this.width,this.height,this.context)}static GetUpdateMethod(){return window.requestAnimationFrame.bind(window)||window.webkitRequestAnimationFrame.bind(window)||window.mozRequestAnimationFrame.bind(window)||window.oRequestAnimationFrame.bind(window)||window.msRequestAnimationFrame.bind(window)||function(t,e){window.setTimeout(function(){t()},1e3/60)}.bind(window)}};var a=class{static getMinWaveWidth(){return 175}static getMaxWaveWidth(){return 300}static getMinWaveHeight(){return 100}static getMaxWaveHeight(){return 200}constructor(){this.x=0,this.y=150,this.length=Math.PI*2,this.step=1,this.canvasWidth=0,this.canvasHeight=0,this.waves=[],this.furthestX=0,this.randomType=0,window.addEventListener("keydown",this.keyboardInput.bind(this),!1)}update(t,e){}fixedUpdate(t,e){}render(t){t.beginPath(),t.moveTo(0,this.canvasHeight);for(let e=0;e<this.waves.length;e++){let i=this.waves[e];if(i.y0!==i.y1)for(let o=i.x0;o<i.x1;o++)t.lineTo(o,n.Lerp(i.y0,i.y1,n.SmoothStep(i.x0,i.x1,o)));else t.lineTo(i.x1,i.y1)}t.lineTo(this.canvasWidth,this.canvasHeight),t.fill()}onCanvasResize(t,e,i){this.canvasHeight===t&&this.canvasHeight===e||(this.ctx=i,this.canvasWidth=t,this.canvasHeight=e,this.resetWaves(),l||this.render(i))}resetWaves(){this.waves.length=0,this.furthestX=0;let t=0;for(t===0&&(this.waves.push({previous:null,next:null,x0:0,y0:this.canvasHeight-a.getMinWaveHeight()-10,x1:a.getMinWaveWidth(),y1:this.canvasHeight-10}),t++);this.furthestX<this.canvasWidth;){let e=this.waves[this.waves.length-1],i=e.y0===e.y1,s={};if(i){let o=this.waves[this.waves.length-2],h=o.y0<o.y1;s=a.curveLine(e,h,this.randomType)}else s=a.straightLine(e);s.y1>this.canvasHeight&&(s.y1=this.canvasHeight),e.next=s,s.previous=e,this.waves.push(s),this.furthestX=s.x1,t++}}getWaveAtPosition(t){for(let e=0;e<this.waves.length;e++){let i=this.waves[e];if(t<i.x1)return i}}static getWaveIntersection(t,e,i){let s=t.x<e.x,o=i;for(;o!==null;){let h=a.waveIntersection(t,e,i);if(h.intersect)return{...h,wave:o};if(s){if(o=o.next,o!==null&&e.x<o.x0)return h}else if(o=o.previous,o!==null&&e.x>o.x1)return h}return{intersect:!1}}static waveIntersection(t,e,i){let s=a.subdivideWave(i);for(let o=0;o<s.length-1;o++){let h=s[o],c=n.LineIntersection(t,e,h,s[o+1]);if(c.intersect===!0)return c}return{intersect:!1}}static subdivideWave(t){let e=[];for(let i=0;i<6;i++){let s=n.Lerp(t.x0,t.x1,i/(6-1));e.push({x:s,y:n.Lerp(t.y0,t.y1,n.SmoothStep(t.x0,t.x1,s))})}return e}static getWaveHeightAtPosition(t,e){for(;t>e.x1&&e.next!==null;)e=e.next;for(;t<e.x0&&e.previous!==null;)e=e.previous;return n.Lerp(e.y0,e.y1,n.SmoothStep(e.x0,e.x1,t))}static straightLine(t){let e=t.x1,i=t.y1;return{previous:null,next:null,x0:e,y0:i,x1:e+5,y1:i}}static curveLine(t,e,i){let s=t.x1,o=s+n.Lerp(a.getMinWaveWidth(),a.getMaxWaveWidth(),this.RandomMethod(i)(s)),h=t.y1,c=e?h-n.Lerp(a.getMinWaveHeight(),a.getMaxWaveHeight(),this.RandomMethod(i)(o)):h+n.Lerp(a.getMinWaveHeight(),a.getMaxWaveHeight(),this.RandomMethod(i)(o));return{previous:null,next:null,x0:s,y0:h,x1:o,y1:c}}static mirror(t){return{x0:t.x1,y0:t.y1,x1:t.x1+t.x1-t.x0,y1:t.y0}}static RandomMethod(t){switch(t){case 0:return function(e){return 0};case 1:return function(e){return n.Random01(e)};case 2:return function(e){return Math.random()};default:return function(e){return 0}}}keyboardInput(t){let e=t.keyCode;e===82&&(this.randomType=2,this.resetWaves(),l||(this.ctx.clearRect(0,0,this.canvasWidth,this.canvasHeight),this.render(this.ctx))),e===84&&(this.randomType=1,this.resetWaves(),l||(this.ctx.clearRect(0,0,this.canvasWidth,this.canvasHeight),this.render(this.ctx))),e===89&&(this.randomType=0,this.resetWaves(),l||(this.ctx.clearRect(0,0,this.canvasWidth,this.canvasHeight),this.render(this.ctx)))}},n=class{static Lerp(t,e,i){return t+(e-t)*i}static LerpBetween(t,e,i,s,o){return n.TryClamp(n.Lerp(t,e,i),s,o)}static Unlerp(t,e,i){return(i-t)/(e-t)}static TryClamp(t,e,i){let s=!1,o=0;return t<e&&(s=!0,o=e-t,t=e),t>i&&(s=!0,o=t-i,t=i),{isClamped:s,result:t,extrapolatedDistance:o}}static Clamp(t,e,i){return Math.min(Math.max(t,e),i)}static SmoothStep(t,e,i){if(i<t)return 0;if(i>=e)return 1;let s=(i-t)/(e-t);return s*s*(3-2*s)}static DotProduct(t,e,i,s){return t*i+e*s}static SurfaceNormal(t){return t.x<0?{x:-t.y,y:t.x}:{x:t.y,y:-t.x}}static Reflect(t,e){let i=n.DotProduct(t.x,t.y,e.x,e.y),s=-2*i;return{x:s*e.x+t.x,y:s*e.y+t.y}}static Rad2Degree(){return 180/Math.PI}static Angle(t,e){return Math.acos(n.DotProduct(t.x,t.y,e.x,e.y))}static Magnitude(t){return Math.sqrt(t.x*t.x+t.y*t.y)}static Normalize(t,e){if(t===0&&e===0)return{x:0,y:0};let i=Math.sqrt(t*t+e*e);return{x:t/i,y:e/i}}static LineIntersection(t,e,i,s){let o=e.x-t.x,h=e.y-t.y,c=s.x-i.x,u=s.y-i.y,x=(-h*(t.x-i.x)+o*(t.y-i.y))/(-c*h+o*u),r=(c*(t.y-i.y)-u*(t.x-i.x))/(-c*h+o*u);if(x>=0&&x<=1&&r>=0&&r<=1){let p=t.x+r*o,f=t.y+r*h;return{intersect:!0,position:{x:p,y:f}}}return{intersect:!1,position:{}}}static Random01(t){return Math.sin(n.DotProduct(t,0,12.9898,78.233))*43758.5453%1}},m=class{constructor(t){this.position={x:300,y:230},this.iPosition=this.position,this.iMaxX=t.canvasWidth-1,this.iMaxY=999999,this.iMinX=0,this.iMinY=-100,this.predictedPosition={x:this.position.x,y:this.position.y},this.predictedFloorHeight=999999,this.waveIntersectionResult={intersect:!1},this.collisionPoint=null,this.floorSlopeDir={x:0,y:1},this.floorNormal={x:1,y:0},this.floorReflectionDir={x:0,y:1},this.velocity={x:0,y:0},this.velocityMultiplier=40,this.isGrounded=!1,this.terrain=t,this.lastFixedUpdate=0,this.predictedNextFixedUpdate=0,this.fixedDeltaTime=0,this.mass=25,this.bounciness=.9,this.friction=.5,this.groundedTolerance=3,this.requiredBounceAngle=50,this.requiredBounceMagnitude=4,this.requiredMagnitude=2.5,window.addEventListener("mousedown",this.mouseInput.bind(this),!1),window.addEventListener("touchstart",this.mouseInput.bind(this),!1)}update(t,e){let i=n.Unlerp(this.lastFixedUpdate,this.predictedNextFixedUpdate,e),s=n.LerpBetween(this.position.x,this.position.x+this.velocity.x*this.velocityMultiplier*this.fixedDeltaTime,i,this.iMinX,this.iMaxX),o=n.LerpBetween(this.position.y,this.position.y-this.velocity.y*this.velocityMultiplier*this.fixedDeltaTime,i,this.iMinY,this.iMaxY);s.isClamped||o.isClamped,this.iPosition={x:s.result,y:o.result}}fixedUpdate(t,e){this.fixedDeltaTime=t,this.lastFixedUpdate=e,this.predictedNextFixedUpdate=e+t*1e3;let i=.981*this.mass*t,s=this.iPosition.y>this.predictedFloorHeight-this.groundedTolerance,o=this.floorSlopeDir.y===0,h=n.Magnitude(this.velocity);if(!s)this.velocity.y-=i,this.isGrounded=!1;else{let r=this.floorSlopeDir;r.y=-r.y;let p=r.y>0?-1:1,f=n.Normalize(this.velocity.x,-this.velocity.y);if(n.Angle(this.floorReflectionDir,f)*n.Rad2Degree()<this.requiredBounceAngle||h<this.requiredBounceMagnitude||this.isGrounded&&r.y>0){this.velocity={x:r.x*h,y:r.y*h};let v={x:r.x*p*i,y:r.y*p*i};o&&(v={x:0,y:0}),this.velocity={x:this.velocity.x+v.x,y:this.velocity.y+v.y},this.isGrounded=!0}else this.velocity={x:this.floorReflectionDir.x*h*this.bounciness,y:-this.floorReflectionDir.y*h*this.bounciness},this.isGrounded=!1}let c={x:this.velocity.x-this.velocity.x*(1-t*this.friction),y:this.velocity.y-this.velocity.y*(1-t*this.friction)};if(this.velocity.x-=c.x,this.velocity.y-=c.y,h=n.Magnitude(this.velocity),s&&h<this.requiredMagnitude&&o&&(this.velocity={x:0,y:0},l=!1),(this.iPosition.x>=this.iMaxX||this.iPosition.x<=this.iMinX)&&(this.velocity.x*=-this.bounciness),this.position=this.iPosition,this.predictedPosition={x:this.position.x+this.velocity.x*this.velocityMultiplier*t,y:this.position.y-this.velocity.y*this.velocityMultiplier*t},this.waveBelow=this.terrain.getWaveAtPosition(this.position.x),this.waveIntersectionResult=a.getWaveIntersection(this.position,this.predictedPosition,this.waveBelow),this.waveIntersectionResult.intersect){let r=n.Unlerp(this.position.y,this.predictedPosition.y,this.waveIntersectionResult.y);this.predictedPosition=this.waveIntersectionResult.position,this.predictedPosition.y-=.1}let u=this.velocity.x>0?1:-1;this.predictedFloorHeight=a.getWaveHeightAtPosition(this.predictedPosition.x,this.waveBelow);let x=a.getWaveHeightAtPosition(this.predictedPosition.x+u,this.waveBelow);this.iMaxY=this.predictedFloorHeight,this.floorSlopeDir=n.Normalize(u,x-this.predictedFloorHeight),this.floorNormal=n.SurfaceNormal(this.floorSlopeDir),this.floorReflectionDir=n.Reflect(n.Normalize(this.velocity.x,-this.velocity.y),this.floorNormal),this.mouseDirection=n.Normalize(this.predictedPosition.x-y.x,this.predictedFloorHeight-y.y)}render(t){this.canvas=t;let e="black",i="purple";if(t.beginPath(),t.arc(this.iPosition.x,this.iPosition.y,10,0,Math.PI*2),t.fillStyle=i,t.fill(),w){let s=100,o="black",h="red",c="yellow",u="blue",x="purple",r="pink",p="green";t.lineWidth=5,t.beginPath(),t.strokeStyle="green",t.moveTo(this.iPosition.x,this.iPosition.y),t.lineTo(this.iPosition.x+this.velocity.x*50,this.iPosition.y+-this.velocity.y*50),t.stroke(),t.beginPath(),t.strokeStyle=u,t.moveTo(this.predictedPosition.x,this.predictedFloorHeight),t.lineTo(this.predictedPosition.x+this.floorReflectionDir.x*s,this.predictedFloorHeight+this.floorReflectionDir.y*s),t.stroke()}t.strokeStyle=e,t.fillStyle=e,t.lineWidth=1}onCanvasResize(t,e,i){this.iMaxX=t}mouseInput(){this.position=y,this.iPosition=y,this.velocity={x:0,y:0},l=!0}},y={x:0,y:0};function M(d){let e=document.getElementById("gameWindow").getBoundingClientRect();y={x:d.clientX-e.left,y:d.clientY-e.top}}function F(d){let e=document.getElementById("gameWindow").getBoundingClientRect();y={x:d.touches[0].clientX-e.left,y:d.touches[0].clientY-e.top}}function R(){let d=new g(144,20),t=new a;d.addGameobject(t),d.addGameobject(new m(t)),onmousemove=M,ontouchmove=F}var w=!1,l=!1;R();})();
